{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to generics-resolver \u00b6 Java generics runtime resolver Release notes - Support - License Resolves declared generics within class hierarchies in order to provide all available type information at runtime. Note Java 8 lambdas are not supported because there is no official way to analyze lambdas due to implementation . It is possible to use some hacks to resolve lambda geneics in some cases, but it's quite fragile (may break on future java releases or not work on other java implementations). Library targets actual classes analysis and, personally, I never really need to analyze lambdas. Library was originally written for guice-persist-orient to support repositories analysis and later used in dropwizard-guicey for extensions analysis. Compatible with Java 6 and above. Main features \u00b6 Resolves generics for hierarchies of any depth (all subclasses and interfaces on any level) Supports composite generics (e.g. Smth<T, K extends List<T>> ) method generics ( <T> T getSmth() ) constructor generics ( <T> Some(T arg) ) outer class generics ( Outer<T>.Inner ) Context api completely prevents incorrect generics resolution (by doing automatic context switching) Sub contexts: build context from Type in current context to properly solve root generics Generics backtracking: track higher type generics from some known middle type To string types converter (useful for logging/reporting) General types comparison api (assignability, compatibility, specificity checks) Alternatives \u00b6 For simple cases (e.g. to resolve class/interface generic value), look, maybe you already have required tool in the classpath (and it will be enough): Guava TypeToken Spring GenericTypeResolver Commons-lang3 TypeUtils","title":"Home"},{"location":"#welcome-to-generics-resolver","text":"Java generics runtime resolver Release notes - Support - License Resolves declared generics within class hierarchies in order to provide all available type information at runtime. Note Java 8 lambdas are not supported because there is no official way to analyze lambdas due to implementation . It is possible to use some hacks to resolve lambda geneics in some cases, but it's quite fragile (may break on future java releases or not work on other java implementations). Library targets actual classes analysis and, personally, I never really need to analyze lambdas. Library was originally written for guice-persist-orient to support repositories analysis and later used in dropwizard-guicey for extensions analysis. Compatible with Java 6 and above.","title":"Welcome to generics-resolver"},{"location":"#main-features","text":"Resolves generics for hierarchies of any depth (all subclasses and interfaces on any level) Supports composite generics (e.g. Smth<T, K extends List<T>> ) method generics ( <T> T getSmth() ) constructor generics ( <T> Some(T arg) ) outer class generics ( Outer<T>.Inner ) Context api completely prevents incorrect generics resolution (by doing automatic context switching) Sub contexts: build context from Type in current context to properly solve root generics Generics backtracking: track higher type generics from some known middle type To string types converter (useful for logging/reporting) General types comparison api (assignability, compatibility, specificity checks)","title":"Main features"},{"location":"#alternatives","text":"For simple cases (e.g. to resolve class/interface generic value), look, maybe you already have required tool in the classpath (and it will be enough): Guava TypeToken Spring GenericTypeResolver Commons-lang3 TypeUtils","title":"Alternatives"},{"location":"getting-started/","text":"Getting started \u00b6 Installation \u00b6 Maven: <dependency> <groupId> ru.vyarus </groupId> <artifactId> generics-resolver </artifactId> <version> 3.0.2 </version> </dependency> Gradle: implementation 'ru.vyarus:generics-resolver:3.0.2' Requires java 6 or above (compatible with java 11). Usage \u00b6 See java reflection tutorial if you have problems with reflection (minimal reflection knowledge is required for usage). Suppose we have class hierarchy: public class Base < T , K > { private List < K > fld ; T doSomething ( K arg ) {...} } public class Root extends Base < Integer , Long > {...} Base class generics could only be known in context of extending class (declared generics). Generics context must be created (from root class): // compute generics for classes in Root hierarchy GenericsContext context = GenericsResolver . resolve ( Root . class ) // switch current class to Base (to work in context of it) . type ( Base . class ); Hint All generics in the root class hierarchy are resolved immediately and resolution data is cached internally, so it is cheap to call generics resolution for the same type in multiple places. Getting Base class generics (in context of Root ): context . generics () == [ Integer . class , Long . class ] Resolving methods: // T doSomething(K arg) MethodGenericsContext methodContext = context . method ( Base . class . getMethod ( \"doSomething\" , Object . class )) // method return class (in context of Root) methodContext . resolveReturnClass () == Integer . class // method parameters (in context of Root) methodContext . resolveParameters () == [ Long . class ] The same way fields, constructors and even direct types could be resolved. Generics context assumed to be used during reflection introspection to provide additional types information. Note It is important to always properly switch context (with .type() ) in order to correctly solve types. BUT if you work with fields, methods or constructors, context will be switched automatically. For example, field resolution: GenericsResolver . resolve ( Root . class ) . resolveFieldsType ( Base . class . getDeclaredField ( ' fld ' )) == List < Long > Note that here we did not do manual context switch to Base class, because field contains declaration type and so countext could switched automatically. Utilities \u00b6 There are 2 API levels: Context API (primary) used to support introspection (reflection analysis) and direct utilities. Context API is safe because it always performs compatibility checks and throws descriptive exceptions. Static utilities . With utilities, usage errors are possible (quite possible to use wrong generics map), but in simple cases it's not a problem. Use API that fits best your use case. How to learn \u00b6 Library is pretty low-level, so it would be easier to first look on usage examples to find exact cases and only after that go to theory section for details.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#installation","text":"Maven: <dependency> <groupId> ru.vyarus </groupId> <artifactId> generics-resolver </artifactId> <version> 3.0.2 </version> </dependency> Gradle: implementation 'ru.vyarus:generics-resolver:3.0.2' Requires java 6 or above (compatible with java 11).","title":"Installation"},{"location":"getting-started/#usage","text":"See java reflection tutorial if you have problems with reflection (minimal reflection knowledge is required for usage). Suppose we have class hierarchy: public class Base < T , K > { private List < K > fld ; T doSomething ( K arg ) {...} } public class Root extends Base < Integer , Long > {...} Base class generics could only be known in context of extending class (declared generics). Generics context must be created (from root class): // compute generics for classes in Root hierarchy GenericsContext context = GenericsResolver . resolve ( Root . class ) // switch current class to Base (to work in context of it) . type ( Base . class ); Hint All generics in the root class hierarchy are resolved immediately and resolution data is cached internally, so it is cheap to call generics resolution for the same type in multiple places. Getting Base class generics (in context of Root ): context . generics () == [ Integer . class , Long . class ] Resolving methods: // T doSomething(K arg) MethodGenericsContext methodContext = context . method ( Base . class . getMethod ( \"doSomething\" , Object . class )) // method return class (in context of Root) methodContext . resolveReturnClass () == Integer . class // method parameters (in context of Root) methodContext . resolveParameters () == [ Long . class ] The same way fields, constructors and even direct types could be resolved. Generics context assumed to be used during reflection introspection to provide additional types information. Note It is important to always properly switch context (with .type() ) in order to correctly solve types. BUT if you work with fields, methods or constructors, context will be switched automatically. For example, field resolution: GenericsResolver . resolve ( Root . class ) . resolveFieldsType ( Base . class . getDeclaredField ( ' fld ' )) == List < Long > Note that here we did not do manual context switch to Base class, because field contains declaration type and so countext could switched automatically.","title":"Usage"},{"location":"getting-started/#utilities","text":"There are 2 API levels: Context API (primary) used to support introspection (reflection analysis) and direct utilities. Context API is safe because it always performs compatibility checks and throws descriptive exceptions. Static utilities . With utilities, usage errors are possible (quite possible to use wrong generics map), but in simple cases it's not a problem. Use API that fits best your use case.","title":"Utilities"},{"location":"getting-started/#how-to-learn","text":"Library is pretty low-level, so it would be easier to first look on usage examples to find exact cases and only after that go to theory section for details.","title":"How to learn"},{"location":"about/history/","text":"3.0.2 (2020-01-16) \u00b6 Fix failing navigation to primitive constructor or method parameter (#5) Improve javadoc mentioning primitives behaviour 3.0.1 (2019-10-10) \u00b6 Fix cycled declarations detection (Something ) Add GenericUtils.orderVariablesForResolution method for ordering type variable declarations Partial (#3) fix: support reversed generics declaration order on class Fix method generics resolution as types instead of classes (#4) Fix constructor generics resolution as types instead of classes 3.0.0 (2018-06-19) \u00b6 Add constructor generics support Add inlying contexts support: generics context building for type \"inside\" of known hierarchy (field, method parameter etc): \"Drill down\" case, when target type could contain generics known in current hierarchy (e.g. field type MyType ) Context methods: context.inlyingType(Type) = GenericsContext - universal inlying context builder (the same as GenericsResolver.resolve(class) if class does not have generics) context.fieldType(Field) - shortcut for fields (guarantee correct base type or error if type not in hierarchy) method(Method).returnType() - shortcut for method return type (guarantee correct base type) method(Method).parameterType(pos) - shortcut for method parameter type (guarantee correct base type) constructor(Constructor).parameterType(pos) - shortcut fot constructor parameter returned context have reference to root context: GenericsContext.rootContext() Inlying context building for higher type then declared (e.g. in field or method). Very special case, required for instance analysis when not just type declarations, but also actual instance is used for analysis: Suppose we have field MyType<String> inside class. But we know that actual instance is MySpecificType<T, K> extends MyType<T>. We need to build generics context for actual class (MySpecificType), but as we know base class type, we can track class generics as MySpecificType<String, Object> (partially tracked) context.inlyingTypeAs(Type, Class) = GenericsContext - universal inlying context building for higher target class Shortcuts, by analogy with simple inlying contexts: fieldTypeAs(Field, Class), returnTypeAs(Class), parameterTypeAs(pos, Class) Target type generics tracking from known declared type generics (e.g. Root<T> extends Base<T> when known Base<String> will resolve to Root<String>). Support composite generic declarations (and any hierarchy depth). Internal analysis logic opened as utilities (for low level usage without GenericsResolver) GenericsResolutionUtils - generics analysis logic (with access to analyzed type) GenericsTrackingUtils - root generics tracking from middle class's known generics TypeUtils - generic utilities for types (ignoring unknown generics) Types deep comparison api: TypesWalker.walk(Type, Type, Visitor) could walk on two types side by side to check or compare actual classes on each level Usages: TypeUtils.isCompatible(Type, Type) - deep types compatibility check TypeUtils.isMoreSpecific(Type, Type) - types specificity check (e.g. to chose more specific like TypeUtils.getMoreSpecificType(Type, Type)) TypeUtils.isAssignable(Type, Type) - checks possibility to cast one type to another (according to known type information) Improved support for multiple interface appearances in hierarchy: before exception was thrown if the same interface appears multiple times with different generics, now different declarations are merged to use the most specific types for interface. Types compatibility explicitly checked during merge. Reworked exceptions: Now all exceptions extend base type GenericsException (runtime) to simplify generic analysis errors interception (catch(GenericException ex)) General tracking exception: GenericsTrackingException - thrown on generics tracking problems General resolution exception: GenericsResolutionException - thrown on type hierarchy generics analysis problems WrongGenericsContextException thrown when supplied type contains generics incompatible with current hierarchy (not reachable from current context) More informative error messages (breaking) UnknownGenericException moved to different package (breaking) NoGenericException removed. Was thrown for resolveGenericsOf(Type) methods when class does not declare generics. Now empty list or null is returned. Context api improvements: Check all supplied types for compatibility with current class: throw exception when type contains generics belonging to other class (avoid usage errors) Constructor generics support: context.constructor(ctor) Kinds of visible generics: genericsMap() - type own generics (as before) ownerGenericsMap() - visible generics of outer class (if current is inner) methodGenericsMap() - method generics constructorGenericsMap() - constructor generics visibleGenericsMap() - all visible generics (type +owner +method/constructor) Type resolution methods (return type with all generic variables replaced with known values): resolveType(Type) = Type Shortcuts: resolveFieldType(Field) - field type without generic variables resolveParameterType(pos) - (method context) parameter type without generic variables resolveReturnType() - (method context) return type without generic variables resolveTypeGenerics(Type) = Type[] Shortcuts for common Field's resolutions: resolveFieldClass(Field) - field class resolveFieldGenerics(Field) - field's class generics (List<Class>) resolveFieldGeneric(Field) - field's class generic (Class) More toString utilities: GenericsContext toString methods for context type: toStringCurrentClassDeclaration() - current with resolved generics (\"MyClass \") toStringCurrentClass() - current class with named generics (\"MyClass \") toStringMethod() - method string with resolved generics (\"void do(MyType)\") toStringConstructor() - constructor string with resolved generics (\"Some(Long)\") (breaking) resolveGenericsOf() called on Class will return upper bounds from generic declaration (previously returns empty map) Improved debugging support: Core context could be printed as string (class hierarchy with resolved generics): context.getGenericsInfo().toString() For customized context string rendering: context.getGenericsInfo().toStringHierarchy(TypeWriter) Direct toString() on context (GenericsContext) prints entire hierarchy with current position marker (\"\u2190 current\"). In intellij idea, current context (with resolved generics) and position could be seen by using \"view value\" link inside debugger Add inner classes support (Outer<T>.Inner, not static) - outer class generics are resolved during hierarchy building: GenericsInfo contains maps with both type generics and owner generics context.ownerClass() returns owner class, visible owner generics are accessible with context.ownerGenericsMap() (empty map for not inner class) For inlying context building, root class may be used as generics source for inner class (if root class hierarchy contains owner class). This is not always true, but, for most cases, inner class is used inside owner and so generics resolution will be correct Improved bounds support: Support multiple upper bounds declaration: My<T extends A & B> now stored as wildcard (? extends A & B) and used for more precise checks (e.g. compatibility, assignability checks). As before, resolveClass(\"T\") will use first upper bound (A). (breaking) avoid upper bound wildcards (transform <? extends Something> -> Something) as only type matter at runtime Affects hierarchy resolution: root generics will not contain Wildcards as before, but just type Compatibility notes: API did not changed, only new methods were added. removed GenericsUtils.getMethodParameters(method, generics): use instead resolveClasses(method.getGenericParameterTypes(), generics) GenericsUtils.resolveGenericsOf() called on Class return upper bounds from generics definition (before was empty result) NoGenericException was removed: detect generic absence by returned result instead UnknownGenericException: was moved to different package now it is impossible to resolve generics in incorrect context, so UnknownGenericException is never thrown (when context api used), instead WrongGenericsContextException could be thrown to indicate incompatible hierarchy It is not important anymore to set correct context (.type(..)): context now automatically switched to resolve generics in correct scope Generics, previously resolved as <? extends Something>, now become simply <Something> (as upper wildcard not useful at runtime) 2.0.1 (2015-12-16) \u00b6 Fix dependent root generics resolution 2.0.0 (2015-06-27) \u00b6 Improve error reporting to show unknown generic name with analyzing type instead of NPE (simplifies usage errors understanding). Support method generics: new method context added (context.method(*)) to properly resolve generics including references to method generics (breaking change) method analysis methods (parameters and return type resolutions) are moved to method context. For example, before it was context.resolveParameters(method), now context.method(method).resolveParameters(). 1.2.1 (2015-03-05) \u00b6 Improve duplicate interfaces support (thanks to Adam Biczok ) 1.2.0 (2015-02-12) \u00b6 Root class generics now resolved (from generic bounds) Support broken hierarchies parsing (when root class generic passed or when target class did not set generics (as with root generics resolved from signature)) 1.1.0 (2014-12-15) \u00b6 Add wildcards support Improve complex generics resolution Add access by generic name methods in GenericsContext Add ability to disable cache using property and method to clear current cache 1.0.0 (2014-11-19) \u00b6 Initial release","title":"Release notes"},{"location":"about/history/#302-2020-01-16","text":"Fix failing navigation to primitive constructor or method parameter (#5) Improve javadoc mentioning primitives behaviour","title":"3.0.2 (2020-01-16)"},{"location":"about/history/#301-2019-10-10","text":"Fix cycled declarations detection (Something ) Add GenericUtils.orderVariablesForResolution method for ordering type variable declarations Partial (#3) fix: support reversed generics declaration order on class Fix method generics resolution as types instead of classes (#4) Fix constructor generics resolution as types instead of classes","title":"3.0.1 (2019-10-10)"},{"location":"about/history/#300-2018-06-19","text":"Add constructor generics support Add inlying contexts support: generics context building for type \"inside\" of known hierarchy (field, method parameter etc): \"Drill down\" case, when target type could contain generics known in current hierarchy (e.g. field type MyType ) Context methods: context.inlyingType(Type) = GenericsContext - universal inlying context builder (the same as GenericsResolver.resolve(class) if class does not have generics) context.fieldType(Field) - shortcut for fields (guarantee correct base type or error if type not in hierarchy) method(Method).returnType() - shortcut for method return type (guarantee correct base type) method(Method).parameterType(pos) - shortcut for method parameter type (guarantee correct base type) constructor(Constructor).parameterType(pos) - shortcut fot constructor parameter returned context have reference to root context: GenericsContext.rootContext() Inlying context building for higher type then declared (e.g. in field or method). Very special case, required for instance analysis when not just type declarations, but also actual instance is used for analysis: Suppose we have field MyType<String> inside class. But we know that actual instance is MySpecificType<T, K> extends MyType<T>. We need to build generics context for actual class (MySpecificType), but as we know base class type, we can track class generics as MySpecificType<String, Object> (partially tracked) context.inlyingTypeAs(Type, Class) = GenericsContext - universal inlying context building for higher target class Shortcuts, by analogy with simple inlying contexts: fieldTypeAs(Field, Class), returnTypeAs(Class), parameterTypeAs(pos, Class) Target type generics tracking from known declared type generics (e.g. Root<T> extends Base<T> when known Base<String> will resolve to Root<String>). Support composite generic declarations (and any hierarchy depth). Internal analysis logic opened as utilities (for low level usage without GenericsResolver) GenericsResolutionUtils - generics analysis logic (with access to analyzed type) GenericsTrackingUtils - root generics tracking from middle class's known generics TypeUtils - generic utilities for types (ignoring unknown generics) Types deep comparison api: TypesWalker.walk(Type, Type, Visitor) could walk on two types side by side to check or compare actual classes on each level Usages: TypeUtils.isCompatible(Type, Type) - deep types compatibility check TypeUtils.isMoreSpecific(Type, Type) - types specificity check (e.g. to chose more specific like TypeUtils.getMoreSpecificType(Type, Type)) TypeUtils.isAssignable(Type, Type) - checks possibility to cast one type to another (according to known type information) Improved support for multiple interface appearances in hierarchy: before exception was thrown if the same interface appears multiple times with different generics, now different declarations are merged to use the most specific types for interface. Types compatibility explicitly checked during merge. Reworked exceptions: Now all exceptions extend base type GenericsException (runtime) to simplify generic analysis errors interception (catch(GenericException ex)) General tracking exception: GenericsTrackingException - thrown on generics tracking problems General resolution exception: GenericsResolutionException - thrown on type hierarchy generics analysis problems WrongGenericsContextException thrown when supplied type contains generics incompatible with current hierarchy (not reachable from current context) More informative error messages (breaking) UnknownGenericException moved to different package (breaking) NoGenericException removed. Was thrown for resolveGenericsOf(Type) methods when class does not declare generics. Now empty list or null is returned. Context api improvements: Check all supplied types for compatibility with current class: throw exception when type contains generics belonging to other class (avoid usage errors) Constructor generics support: context.constructor(ctor) Kinds of visible generics: genericsMap() - type own generics (as before) ownerGenericsMap() - visible generics of outer class (if current is inner) methodGenericsMap() - method generics constructorGenericsMap() - constructor generics visibleGenericsMap() - all visible generics (type +owner +method/constructor) Type resolution methods (return type with all generic variables replaced with known values): resolveType(Type) = Type Shortcuts: resolveFieldType(Field) - field type without generic variables resolveParameterType(pos) - (method context) parameter type without generic variables resolveReturnType() - (method context) return type without generic variables resolveTypeGenerics(Type) = Type[] Shortcuts for common Field's resolutions: resolveFieldClass(Field) - field class resolveFieldGenerics(Field) - field's class generics (List<Class>) resolveFieldGeneric(Field) - field's class generic (Class) More toString utilities: GenericsContext toString methods for context type: toStringCurrentClassDeclaration() - current with resolved generics (\"MyClass \") toStringCurrentClass() - current class with named generics (\"MyClass \") toStringMethod() - method string with resolved generics (\"void do(MyType)\") toStringConstructor() - constructor string with resolved generics (\"Some(Long)\") (breaking) resolveGenericsOf() called on Class will return upper bounds from generic declaration (previously returns empty map) Improved debugging support: Core context could be printed as string (class hierarchy with resolved generics): context.getGenericsInfo().toString() For customized context string rendering: context.getGenericsInfo().toStringHierarchy(TypeWriter) Direct toString() on context (GenericsContext) prints entire hierarchy with current position marker (\"\u2190 current\"). In intellij idea, current context (with resolved generics) and position could be seen by using \"view value\" link inside debugger Add inner classes support (Outer<T>.Inner, not static) - outer class generics are resolved during hierarchy building: GenericsInfo contains maps with both type generics and owner generics context.ownerClass() returns owner class, visible owner generics are accessible with context.ownerGenericsMap() (empty map for not inner class) For inlying context building, root class may be used as generics source for inner class (if root class hierarchy contains owner class). This is not always true, but, for most cases, inner class is used inside owner and so generics resolution will be correct Improved bounds support: Support multiple upper bounds declaration: My<T extends A & B> now stored as wildcard (? extends A & B) and used for more precise checks (e.g. compatibility, assignability checks). As before, resolveClass(\"T\") will use first upper bound (A). (breaking) avoid upper bound wildcards (transform <? extends Something> -> Something) as only type matter at runtime Affects hierarchy resolution: root generics will not contain Wildcards as before, but just type Compatibility notes: API did not changed, only new methods were added. removed GenericsUtils.getMethodParameters(method, generics): use instead resolveClasses(method.getGenericParameterTypes(), generics) GenericsUtils.resolveGenericsOf() called on Class return upper bounds from generics definition (before was empty result) NoGenericException was removed: detect generic absence by returned result instead UnknownGenericException: was moved to different package now it is impossible to resolve generics in incorrect context, so UnknownGenericException is never thrown (when context api used), instead WrongGenericsContextException could be thrown to indicate incompatible hierarchy It is not important anymore to set correct context (.type(..)): context now automatically switched to resolve generics in correct scope Generics, previously resolved as <? extends Something>, now become simply <Something> (as upper wildcard not useful at runtime)","title":"3.0.0 (2018-06-19)"},{"location":"about/history/#201-2015-12-16","text":"Fix dependent root generics resolution","title":"2.0.1 (2015-12-16)"},{"location":"about/history/#200-2015-06-27","text":"Improve error reporting to show unknown generic name with analyzing type instead of NPE (simplifies usage errors understanding). Support method generics: new method context added (context.method(*)) to properly resolve generics including references to method generics (breaking change) method analysis methods (parameters and return type resolutions) are moved to method context. For example, before it was context.resolveParameters(method), now context.method(method).resolveParameters().","title":"2.0.0 (2015-06-27)"},{"location":"about/history/#121-2015-03-05","text":"Improve duplicate interfaces support (thanks to Adam Biczok )","title":"1.2.1 (2015-03-05)"},{"location":"about/history/#120-2015-02-12","text":"Root class generics now resolved (from generic bounds) Support broken hierarchies parsing (when root class generic passed or when target class did not set generics (as with root generics resolved from signature))","title":"1.2.0 (2015-02-12)"},{"location":"about/history/#110-2014-12-15","text":"Add wildcards support Improve complex generics resolution Add access by generic name methods in GenericsContext Add ability to disable cache using property and method to clear current cache","title":"1.1.0 (2014-12-15)"},{"location":"about/history/#100-2014-11-19","text":"Initial release","title":"1.0.0 (2014-11-19)"},{"location":"about/license/","text":"The MIT License (MIT) Copyright \u00a9 2014-2020, Vyacheslav Rusakov Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/support/","text":"Support \u00b6 Gitter - chat Github issues - problems / enhancements","title":"Support"},{"location":"about/support/#support","text":"Gitter - chat Github issues - problems / enhancements","title":"Support"},{"location":"examples/compat/","text":"Types compatibility check \u00b6 Suppose you have some class: class Conf { SubConf < List < String >> sub ; } And some other class: class Listener { listen ( SubConf < List < Integer >> obj ); } And you want to check if field value from Conf could be used in listener: // for more complex cases there may be generics resolution too // pure reflection just for clarity Type listenerArg = Listener . class . getMethod ( \"listen\" , SubConf . class ) . getGenericParameterTypes ()[ 0 ]; Type confField = Conf . getField ( \"sub\" ). getGenericType (); // not assignable because of list generics: String vs Integer TypeUtils . isAssignable ( confField , listnerArg ) == false Note Possible name variables (not resolved) in types are replaced with Object.class ( List<T> == List<Object> ). Use context.resolveType(type) to replace type variables with known types before comparison (and use context.resolveTypeGenerics(type) to get direct generics of type). Types may also be checked for compatibility: Type one = List < Number > // ParameterizedType Type two = List < Integer > // ParameterizedType TypeUtils . isAssignable ( one , two ) == false // means one assignable to two or two assignable to one TypeUtils . isCompatible ( one , two ) == true // detects type with more specific definition TypeUtils . isMoreSpecific ( one , two ) == false TypeUtils . getMoreSpecific ( one , two ) == two If required, you can implement your own logic based on types comparison: see types walker section.","title":"Types compatiblity check"},{"location":"examples/compat/#types-compatibility-check","text":"Suppose you have some class: class Conf { SubConf < List < String >> sub ; } And some other class: class Listener { listen ( SubConf < List < Integer >> obj ); } And you want to check if field value from Conf could be used in listener: // for more complex cases there may be generics resolution too // pure reflection just for clarity Type listenerArg = Listener . class . getMethod ( \"listen\" , SubConf . class ) . getGenericParameterTypes ()[ 0 ]; Type confField = Conf . getField ( \"sub\" ). getGenericType (); // not assignable because of list generics: String vs Integer TypeUtils . isAssignable ( confField , listnerArg ) == false Note Possible name variables (not resolved) in types are replaced with Object.class ( List<T> == List<Object> ). Use context.resolveType(type) to replace type variables with known types before comparison (and use context.resolveTypeGenerics(type) to get direct generics of type). Types may also be checked for compatibility: Type one = List < Number > // ParameterizedType Type two = List < Integer > // ParameterizedType TypeUtils . isAssignable ( one , two ) == false // means one assignable to two or two assignable to one TypeUtils . isCompatible ( one , two ) == true // detects type with more specific definition TypeUtils . isMoreSpecific ( one , two ) == false TypeUtils . getMoreSpecific ( one , two ) == two If required, you can implement your own logic based on types comparison: see types walker section.","title":"Types compatibility check"},{"location":"examples/construct/","text":"Construct custom types \u00b6 Custom type containers (used internally for types repackaging) may be used for constructing types: new ParameterizedTypeImpl ( List . class . String . class ) // List<String> WildcardTypeImpl . upper ( String . class ) // ? extends String WildcardTYpeImpl . lower ( String . class ) // ? super String new GenericArrayTypeImpl ( String . class ) // String[] Note that upper bounded wildcard constructor allows multiple upper bounds, for example: WildcardTypeImpl . upper ( Number . class , Comparable . class ) which creates impossible (to declare in java) wildcard ? extends Number & Comparable . This is used internally for multiple bounded variable declaration repackage (which could contain multiple bounds) : T extends Number & Comparable . But, for example, groovy allows multiple bounds in wildcards. Custom type container could be used in toString logic: TypeToStringUtils . toStringType ( new ParameterizedTypeImpl ( List . class . String . class ), Collections . emptyMap ()) == \"List<String>\" ;","title":"Type construction"},{"location":"examples/construct/#construct-custom-types","text":"Custom type containers (used internally for types repackaging) may be used for constructing types: new ParameterizedTypeImpl ( List . class . String . class ) // List<String> WildcardTypeImpl . upper ( String . class ) // ? extends String WildcardTYpeImpl . lower ( String . class ) // ? super String new GenericArrayTypeImpl ( String . class ) // String[] Note that upper bounded wildcard constructor allows multiple upper bounds, for example: WildcardTypeImpl . upper ( Number . class , Comparable . class ) which creates impossible (to declare in java) wildcard ? extends Number & Comparable . This is used internally for multiple bounded variable declaration repackage (which could contain multiple bounds) : T extends Number & Comparable . But, for example, groovy allows multiple bounds in wildcards. Custom type container could be used in toString logic: TypeToStringUtils . toStringType ( new ParameterizedTypeImpl ( List . class . String . class ), Collections . emptyMap ()) == \"List<String>\" ;","title":"Construct custom types"},{"location":"examples/di/","text":"DI binding \u00b6 Universal binding mechanism: suppose we have Provider<T> instances and want to bind them (in DI container like guice): Provider providerInstance = ...; Class type = GenericsResolver . resolve ( providerInstance . getClass ()) . type ( Provider . class ) . generic ( 0 ); bind ( type ). toProvider ( providerInstance ); For example, for instance of class MyProvider implements Provider<MyType> binding will be bind(MyType.class),toProvider(MyProviderInstance) Note Guice binding syntax used, just an example to get overall idea. Warning This will work only if generic was decled for provider class because otherwise generic would be resolved as Object (if generic not declared - nowhere to get type information) Universal mechanism (for any type) \u00b6 And here is an example of universal binding mechanism (pseudo DI): public void bindExtension ( Class extensionType , Class contractType ) { // actual generics of required extension Type [] generics = GenericsResolver . resolve ( extensionType ) . type ( contractType ) . genericTypes () . toArray ( new Type [ 0 ]); // actual extension type (specific to provided instance) Type bindingType = generics . length > 0 ? new ParameterizedTypeImpl ( contractType , generics ) : contractType ; bind ( bindingType ). to ( extensionObjectType ) } For example, if we have extension class MyExtension implements Useful<String> we can bind it with correct generics bindExtension(MyExtension.class, Useful.class) which perform bind(Useful<String>).to(MyExtension.class) .","title":"DI binding"},{"location":"examples/di/#di-binding","text":"Universal binding mechanism: suppose we have Provider<T> instances and want to bind them (in DI container like guice): Provider providerInstance = ...; Class type = GenericsResolver . resolve ( providerInstance . getClass ()) . type ( Provider . class ) . generic ( 0 ); bind ( type ). toProvider ( providerInstance ); For example, for instance of class MyProvider implements Provider<MyType> binding will be bind(MyType.class),toProvider(MyProviderInstance) Note Guice binding syntax used, just an example to get overall idea. Warning This will work only if generic was decled for provider class because otherwise generic would be resolved as Object (if generic not declared - nowhere to get type information)","title":"DI binding"},{"location":"examples/di/#universal-mechanism-for-any-type","text":"And here is an example of universal binding mechanism (pseudo DI): public void bindExtension ( Class extensionType , Class contractType ) { // actual generics of required extension Type [] generics = GenericsResolver . resolve ( extensionType ) . type ( contractType ) . genericTypes () . toArray ( new Type [ 0 ]); // actual extension type (specific to provided instance) Type bindingType = generics . length > 0 ? new ParameterizedTypeImpl ( contractType , generics ) : contractType ; bind ( bindingType ). to ( extensionObjectType ) } For example, if we have extension class MyExtension implements Useful<String> we can bind it with correct generics bindExtension(MyExtension.class, Useful.class) which perform bind(Useful<String>).to(MyExtension.class) .","title":"Universal mechanism (for any type)"},{"location":"examples/direct/","text":"Direct generics resolution \u00b6 Generics resolution process is actually building a map of all types and their generics (this map is used inside resolution context for types navigation). class Base < T extends Number > {} class Root extends Base < Integer > {} Get generics hierarchy: GenericsResolutionUtils . resolve ( Root . class ) == [ Root . class : [], Base . class : [ \"T\" : Integer . class ]]; Or just resolve generics resolution from definition: GenericsResolutionUtils . resolveRawGenerics ( Base . class ) == [ \"T\" : Number . class ]; Or, if generics already known as List, it could be converted to map: Map < String , Type > generics = GenericsUtils . createGenericsMap ( Some . class , knownGenericsList ); For example, we know that class MyType<T, K> has [String.class, Integer.class] generics. Then we can convert it to map: GenericsUtils . createGenericsMap ( MyType . class , [ String . class , Integer . class ]) == [ \"T\" : String . class , \"K\" : Integer . class ] And use resulted map for utility calls (e.g. GenericsUtils or ToStringUtils ).","title":"Direct generics resolution"},{"location":"examples/direct/#direct-generics-resolution","text":"Generics resolution process is actually building a map of all types and their generics (this map is used inside resolution context for types navigation). class Base < T extends Number > {} class Root extends Base < Integer > {} Get generics hierarchy: GenericsResolutionUtils . resolve ( Root . class ) == [ Root . class : [], Base . class : [ \"T\" : Integer . class ]]; Or just resolve generics resolution from definition: GenericsResolutionUtils . resolveRawGenerics ( Base . class ) == [ \"T\" : Number . class ]; Or, if generics already known as List, it could be converted to map: Map < String , Type > generics = GenericsUtils . createGenericsMap ( Some . class , knownGenericsList ); For example, we know that class MyType<T, K> has [String.class, Integer.class] generics. Then we can convert it to map: GenericsUtils . createGenericsMap ( MyType . class , [ String . class , Integer . class ]) == [ \"T\" : String . class , \"K\" : Integer . class ] And use resulted map for utility calls (e.g. GenericsUtils or ToStringUtils ).","title":"Direct generics resolution"},{"location":"examples/hierarchy/","text":"Type hierarchy \u00b6 class Base < T , K > { } class Root extends Base < Integer , Long > {} Get all types in class hierarchy (classes and interfaces): GenericsResolver . resove ( Root ). getGenericsInfo (). getComposingTypes () == [ Root . class , Base . class ] Print hierarchy: GenericsResolver . resove ( Root ). getGenericsInfo (). toString (); class Root extends Base < Integer , Long > Hierarchy includes all classes and interfaces (even without declared generics). Interface specifics \u00b6 One interface may appear in multiple hierarchy \"branches\", but its generics will be either the same or compatible (otherwise java will simply not compile). Generics resolution will select the most specific generics. For example: public interface Some < T , K > {} public interface One extends Some < Long , Number > {} public interface Two extends Some < Number , Integer > {} public class Root implmenets One , Two {} Generics of Some would be resolved (under Root ) as [Long, Integer] (compilation from both declarations).","title":"Type hierarchy"},{"location":"examples/hierarchy/#type-hierarchy","text":"class Base < T , K > { } class Root extends Base < Integer , Long > {} Get all types in class hierarchy (classes and interfaces): GenericsResolver . resove ( Root ). getGenericsInfo (). getComposingTypes () == [ Root . class , Base . class ] Print hierarchy: GenericsResolver . resove ( Root ). getGenericsInfo (). toString (); class Root extends Base < Integer , Long > Hierarchy includes all classes and interfaces (even without declared generics).","title":"Type hierarchy"},{"location":"examples/hierarchy/#interface-specifics","text":"One interface may appear in multiple hierarchy \"branches\", but its generics will be either the same or compatible (otherwise java will simply not compile). Generics resolution will select the most specific generics. For example: public interface Some < T , K > {} public interface One extends Some < Long , Number > {} public interface Two extends Some < Number , Integer > {} public class Root implmenets One , Two {} Generics of Some would be resolved (under Root ) as [Long, Integer] (compilation from both declarations).","title":"Interface specifics"},{"location":"examples/inception/","text":"Sub types analysis \u00b6 Suppose you have hierarchical pojo (e.g. configuration class): class BaseConf < T > { SubConf < T > dbConf ; } class Conf extends Base < String > {} You want to analyze dbConf's type ( SubConf<T> in context of Conf ): // build context for root class GenericsContext context = GenericsResolver . resove ( Conf . class ) // build sub context for field type . fieldType ( Conf . class . getDeclaredField ( \"dbConf\" )); // working in sub context as in usual context context . currentClass () == SubConf . class context . generics () == [ String . class ] ...","title":"Sub types analysis"},{"location":"examples/inception/#sub-types-analysis","text":"Suppose you have hierarchical pojo (e.g. configuration class): class BaseConf < T > { SubConf < T > dbConf ; } class Conf extends Base < String > {} You want to analyze dbConf's type ( SubConf<T> in context of Conf ): // build context for root class GenericsContext context = GenericsResolver . resove ( Conf . class ) // build sub context for field type . fieldType ( Conf . class . getDeclaredField ( \"dbConf\" )); // working in sub context as in usual context context . currentClass () == SubConf . class context . generics () == [ String . class ] ...","title":"Sub types analysis"},{"location":"examples/instance/","text":"Instance analysis \u00b6 This is very specific case when we use actual instances to get more type information. For example, when we have public class Some { Object something ; } We can't tell anything about something filed type (simply nothing declared). But if we have instance of Some , we can look field value and improve known type information. Suppose you want to analyze current object instance structure. For example, you have configuration object and you want to compute its values as paths: class Conf { Base < String > sub ; } Conf conf = ... // instance GenericsContext context = GenericsResolver . resolve ( conf . getClass ()) Map < String , PropertyPath > configPaths = new HashMap <>(); extractConfigPaths ( configPaths , \"\" , context ) void extractConfigPaths ( Map < String , Object > paths , String prefix , GenericsContext context ) { Class type = context . currentClass (); // possible sub clas fields ignored for simplicity for ( Field field : type . getDeclaredFields ()) { Object value = field . getValue (); // simplification! // in real life type analysis logic will be more complex // and the most specific type resolution would be required Class fieldType = context . resolveFieldClass ( field ); String fieldPath = prefix + \".\" + field . getName (); // simplification: primitives considered as final value, // others as pojos to go deeper if ( fieldType . isPrimitive ()) { paths . put ( fieldPath , value ); } else { extractConfigPaths ( paths , fieldPath , // simplification: value not checked for null context . fieldTypeAs ( field , value . getClass ())); } } } Pay attention to: context.fieldTypeAs(field, value.getClass()) . Class Conf declares field as Base<String> sub , but actually there might be more specific type (as we have object instance, we know exact type for sure ( value.getClass() == Specific.class )): class Specific < T , K > extends Base < K > { T unknown ; K known ; } To properly introspect fields of Specific we need to build generics context for it, but we know generics only for its base class ( Base<String> ). context.fieldTypeAs will: Track generics declaration from root class and resolve one generic: Specific<Object, String> Build new context for Specific<Object, String> . With it we can partially know actual field types: \"sub.unknown\", Object.class \"sub.known\", String.class (without root analysis they both would be recognized as Object.class) Note that even if specific class generics are not trackable ( class Specific2 extends Base - generics not trackable), resolved hierarchy will still use known generic values for sub hierarchy, starting from class with known generics (because we know they are correct for sure): class Specific2 extends Base<String>","title":"Instance analysis"},{"location":"examples/instance/#instance-analysis","text":"This is very specific case when we use actual instances to get more type information. For example, when we have public class Some { Object something ; } We can't tell anything about something filed type (simply nothing declared). But if we have instance of Some , we can look field value and improve known type information. Suppose you want to analyze current object instance structure. For example, you have configuration object and you want to compute its values as paths: class Conf { Base < String > sub ; } Conf conf = ... // instance GenericsContext context = GenericsResolver . resolve ( conf . getClass ()) Map < String , PropertyPath > configPaths = new HashMap <>(); extractConfigPaths ( configPaths , \"\" , context ) void extractConfigPaths ( Map < String , Object > paths , String prefix , GenericsContext context ) { Class type = context . currentClass (); // possible sub clas fields ignored for simplicity for ( Field field : type . getDeclaredFields ()) { Object value = field . getValue (); // simplification! // in real life type analysis logic will be more complex // and the most specific type resolution would be required Class fieldType = context . resolveFieldClass ( field ); String fieldPath = prefix + \".\" + field . getName (); // simplification: primitives considered as final value, // others as pojos to go deeper if ( fieldType . isPrimitive ()) { paths . put ( fieldPath , value ); } else { extractConfigPaths ( paths , fieldPath , // simplification: value not checked for null context . fieldTypeAs ( field , value . getClass ())); } } } Pay attention to: context.fieldTypeAs(field, value.getClass()) . Class Conf declares field as Base<String> sub , but actually there might be more specific type (as we have object instance, we know exact type for sure ( value.getClass() == Specific.class )): class Specific < T , K > extends Base < K > { T unknown ; K known ; } To properly introspect fields of Specific we need to build generics context for it, but we know generics only for its base class ( Base<String> ). context.fieldTypeAs will: Track generics declaration from root class and resolve one generic: Specific<Object, String> Build new context for Specific<Object, String> . With it we can partially know actual field types: \"sub.unknown\", Object.class \"sub.known\", String.class (without root analysis they both would be recognized as Object.class) Note that even if specific class generics are not trackable ( class Specific2 extends Base - generics not trackable), resolved hierarchy will still use known generic values for sub hierarchy, starting from class with known generics (because we know they are correct for sure): class Specific2 extends Base<String>","title":"Instance analysis"},{"location":"examples/reflect/","text":"Reflection assist \u00b6 When class is deeply analyzed (often methods or fields processing) context is prepared once and navigated to required type in the hierarchy: // preparing generics context before analysis because it would be impossible // to resolve correct generics for required class in hierarchy GenericsContext context = GenericsResolver . resolve ( Root ); analyzeType ( context , Root . class ); void analyzeType ( GenericsContext context ) { Class type = context . currentClass (); // do some analysis (e.g. review methods) for ( Method method : type . getDeclaredMethods ()) { Class res = context . method ( method ). resolveReturnClass (); // collection returned if ( Iterable . isAssignableFrom ( res )) { Class collectionType = context . method ( method ) . resolveReturnTypeGeneric (); //... } } // example type resolvution inside class (note there is a shortcut method .resolveFieldClass(), // here raw resolution used as an example) Class fieldType = context . resolveClass ( type . getDeclaredField ( \"smth\" ). getGenericType ()) // continue analysis for superclass Class superclass = type . getSuperclass (); analyzeType ( context . type ( superclass )); }","title":"Refelction assist"},{"location":"examples/reflect/#reflection-assist","text":"When class is deeply analyzed (often methods or fields processing) context is prepared once and navigated to required type in the hierarchy: // preparing generics context before analysis because it would be impossible // to resolve correct generics for required class in hierarchy GenericsContext context = GenericsResolver . resolve ( Root ); analyzeType ( context , Root . class ); void analyzeType ( GenericsContext context ) { Class type = context . currentClass (); // do some analysis (e.g. review methods) for ( Method method : type . getDeclaredMethods ()) { Class res = context . method ( method ). resolveReturnClass (); // collection returned if ( Iterable . isAssignableFrom ( res )) { Class collectionType = context . method ( method ) . resolveReturnTypeGeneric (); //... } } // example type resolvution inside class (note there is a shortcut method .resolveFieldClass(), // here raw resolution used as an example) Class fieldType = context . resolveClass ( type . getDeclaredField ( \"smth\" ). getGenericType ()) // continue analysis for superclass Class superclass = type . getSuperclass (); analyzeType ( context . type ( superclass )); }","title":"Reflection assist"},{"location":"examples/resolution/","text":"Base type generics \u00b6 Resolve generics from implemented interface or extended class. Common case for various extension mechanisms is to know actual generics of some extension interface for actual extension class: interface Extension < V > {} class ListExtension implements Extension < List < String >> {} GenericsResolver . resolve ( ListExtension . class ) . type ( Extension . class ) . genericType ( \"V\" ) == List < String > // (ParameterizedType)","title":"Base type generics"},{"location":"examples/resolution/#base-type-generics","text":"Resolve generics from implemented interface or extended class. Common case for various extension mechanisms is to know actual generics of some extension interface for actual extension class: interface Extension < V > {} class ListExtension implements Extension < List < String >> {} GenericsResolver . resolve ( ListExtension . class ) . type ( Extension . class ) . genericType ( \"V\" ) == List < String > // (ParameterizedType)","title":"Base type generics"},{"location":"examples/safe-resolve/","text":"Safe resolution \u00b6 class Base < T > { private T field ; public < K extends Comparable > K get (){} } // generic with the same name class Base2 < T > extends Base < Long > { private T field ; } class Root extends Base2 < String > {} // not in Root hierarchy class NotInside < T > { private List < T > field ; } After context resolution, any generics, containing in type hierarchy would be properly resolved: // note context class is Root GenericsContext context = GenericsResolver . resolve ( Root . class ) // context.toString(): // class Root <-- current // extends Base2<String> // extends Base<Long> // automatically detected context Base and use correct generics context . resolveClass ( Base . class . getDeclaredField ( \"field\" ). getGenericType ()) == Long . class // Base2 recognized and appropriate generic used context . resolveClass ( Base2 . class . getDeclaredField ( \"field\" ). getGenericType ()) == String . class // method context automatically detected and type properly resolved context . resolveClass ( Base . class . getMethod ( \"get\" ). getGenericReturnType ())== Comparable . class But, when generics in type belongs to different hierarchy: context . resolveClass ( NotInside . class . getDeclaredField ( \"field\" ). getGenericType ()) exception is thrown: ru.vyarus.java.generics.resolver.error.WrongGenericsContextException: Type List<T> contains generic 'T' (defined on NotInside<T>) and can't be resolved in context of current class Root. Generic does not belong to any type in current context hierarchy: class Root extends Base2<String> extends Base<Long> at ru.vyarus.java.generics.resolver.context.GenericsContext.chooseContext(GenericsContext.java:233) at ru.vyarus.java.generics.resolver.context.AbstractGenericsContext.resolveClass(AbstractGenericsContext.java:273) Such detections are possible because java type variables always hold declaration information and so library could compare current generics context type with generic declaration. This almost avoids hard to track errors (which could appear due to resolution in wrong context). Possible cases \u00b6 In some cases you can still get wrong results. For example, by forgetting to switch context. In the above example both Base and Base2 declares generic T . If you want to resolve Base class generic, but, by accident, context type currently is at Base2 ( .type(Base2.class) ) then: context . generic ( \"T\" ) == String . class You actually get generic of class Base2 , because its currently selected, and it also has declared generic named 'T' (library can't guess here your actual intention). Of course, if context class does not contain generic with requested name error would be thrown, but generics are named the same too often.","title":"Safe resolution"},{"location":"examples/safe-resolve/#safe-resolution","text":"class Base < T > { private T field ; public < K extends Comparable > K get (){} } // generic with the same name class Base2 < T > extends Base < Long > { private T field ; } class Root extends Base2 < String > {} // not in Root hierarchy class NotInside < T > { private List < T > field ; } After context resolution, any generics, containing in type hierarchy would be properly resolved: // note context class is Root GenericsContext context = GenericsResolver . resolve ( Root . class ) // context.toString(): // class Root <-- current // extends Base2<String> // extends Base<Long> // automatically detected context Base and use correct generics context . resolveClass ( Base . class . getDeclaredField ( \"field\" ). getGenericType ()) == Long . class // Base2 recognized and appropriate generic used context . resolveClass ( Base2 . class . getDeclaredField ( \"field\" ). getGenericType ()) == String . class // method context automatically detected and type properly resolved context . resolveClass ( Base . class . getMethod ( \"get\" ). getGenericReturnType ())== Comparable . class But, when generics in type belongs to different hierarchy: context . resolveClass ( NotInside . class . getDeclaredField ( \"field\" ). getGenericType ()) exception is thrown: ru.vyarus.java.generics.resolver.error.WrongGenericsContextException: Type List<T> contains generic 'T' (defined on NotInside<T>) and can't be resolved in context of current class Root. Generic does not belong to any type in current context hierarchy: class Root extends Base2<String> extends Base<Long> at ru.vyarus.java.generics.resolver.context.GenericsContext.chooseContext(GenericsContext.java:233) at ru.vyarus.java.generics.resolver.context.AbstractGenericsContext.resolveClass(AbstractGenericsContext.java:273) Such detections are possible because java type variables always hold declaration information and so library could compare current generics context type with generic declaration. This almost avoids hard to track errors (which could appear due to resolution in wrong context).","title":"Safe resolution"},{"location":"examples/safe-resolve/#possible-cases","text":"In some cases you can still get wrong results. For example, by forgetting to switch context. In the above example both Base and Base2 declares generic T . If you want to resolve Base class generic, but, by accident, context type currently is at Base2 ( .type(Base2.class) ) then: context . generic ( \"T\" ) == String . class You actually get generic of class Base2 , because its currently selected, and it also has declared generic named 'T' (library can't guess here your actual intention). Of course, if context class does not contain generic with requested name error would be thrown, but generics are named the same too often.","title":"Possible cases"},{"location":"examples/sanitizer/","text":"Types sanitizer \u00b6 You may already have some api for working with Type objects. In this case resolver could be used to replace all generic variables with actual types: class Base < T > { List < T > field ; } class Root extends Base < Integer > {} GenericsContext context = GenericsResolver . resovle ( Root . class ); // pure reflection, actual type is List<T> Type fieldType = Base . class . getField ( \"field\" ); // sanitize type to List<Integer> fieldType = context . type ( Base . class ). resovleType ( fieldType ); // continue working with pure type Note Type resolution is actually complete type repackage (if required) to replace TypeVariable in it with actual generic value. Alternatively, if class hierarchy is not known and we want to remove generics in context of current class only Type fieldType = GenericsUtils . resolveTypeVariables ( fieldType , new IgnoreGenericsMap ()) Will resolve type as List<Object> (unknown generic \"T\" resolved as Object.class). Sometimes it is useful to extract generics of type: // type's generics Type [] typeGenerics = GenericsUtils . getGenerics ( type , generics ); // type's with replaced variables Type [] sanitizedGenerics = GenericsUtils . resolveTypeVariables ( typeGenerics , generics ); Note: Generics map (generics) of host type could be taken form host type's generics context ( context.visibleGenericsMap() ) or manually (see generics map direct resolution example). For example, if original type was Map<String, List<T>> then sanitizedGenerics will be [String, List<Integer>] (suppose T is Integer in current context).","title":"Type sanitizer"},{"location":"examples/sanitizer/#types-sanitizer","text":"You may already have some api for working with Type objects. In this case resolver could be used to replace all generic variables with actual types: class Base < T > { List < T > field ; } class Root extends Base < Integer > {} GenericsContext context = GenericsResolver . resovle ( Root . class ); // pure reflection, actual type is List<T> Type fieldType = Base . class . getField ( \"field\" ); // sanitize type to List<Integer> fieldType = context . type ( Base . class ). resovleType ( fieldType ); // continue working with pure type Note Type resolution is actually complete type repackage (if required) to replace TypeVariable in it with actual generic value. Alternatively, if class hierarchy is not known and we want to remove generics in context of current class only Type fieldType = GenericsUtils . resolveTypeVariables ( fieldType , new IgnoreGenericsMap ()) Will resolve type as List<Object> (unknown generic \"T\" resolved as Object.class). Sometimes it is useful to extract generics of type: // type's generics Type [] typeGenerics = GenericsUtils . getGenerics ( type , generics ); // type's with replaced variables Type [] sanitizedGenerics = GenericsUtils . resolveTypeVariables ( typeGenerics , generics ); Note: Generics map (generics) of host type could be taken form host type's generics context ( context.visibleGenericsMap() ) or manually (see generics map direct resolution example). For example, if original type was Map<String, List<T>> then sanitizedGenerics will be [String, List<Integer>] (suppose T is Integer in current context).","title":"Types sanitizer"},{"location":"examples/track/","text":"Generics tracking \u00b6 Tracking is a reverse process to generics resolution: when you know some type's generics and you want to calculate generics of some root type. class Base < T > { } class Root < K , P extends Comparable > extends Base < K []> {} Suppose we know Base<String[]> and we want to track Root class generics: GenericsTrackingUtils . track ( Root , Base , [ \"T\" : String []]) == [ \"K\" : String , \"P\" : Comparable ] Here we don't have any connection from root generic \"P\" and base class, so its resolved by raw declaration (as declared upper bound).","title":"Generics tracking"},{"location":"examples/track/#generics-tracking","text":"Tracking is a reverse process to generics resolution: when you know some type's generics and you want to calculate generics of some root type. class Base < T > { } class Root < K , P extends Comparable > extends Base < K []> {} Suppose we know Base<String[]> and we want to track Root class generics: GenericsTrackingUtils . track ( Root , Base , [ \"T\" : String []]) == [ \"K\" : String , \"P\" : Comparable ] Here we don't have any connection from root generic \"P\" and base class, so its resolved by raw declaration (as declared upper bound).","title":"Generics tracking"},{"location":"examples/utils/","text":"Utilities usage \u00b6 In most cases, to use utility directly, all you need to know is type's generics map. It could be either obtained from context ( context.type(Some.class).visibleGenericsMap() ) or resolved directly . class Some < T > { T field ; } Suppose you have generics resolved as generics variable. Map < String , Type > generics = [ \"T\" : List < String >]; Note that this map must include all visible generics (including outer class, method or constructor if they could appear in target types), so better use context api to obtain complete generics map (otherwise UnkownGenericsException could arise at some point). Type field = Some . class . getDeclaredField ( \"field\" ); GenericsUtils . resolveClass ( field , generics ) == List . class ; GenericsUtils . resolveGenericsOf ( field , generics ) == String . class ; TypeToStringUtils . toStringType ( field , generics ) == \"List<String>\" ; TypeToStringUtils . toStringWithNamedGenerics ( field ) == \"List<T>\" ; TypeToStringUtils . toStringWithGenerics ( Some . class , generics ) == \"Some<List<String>>\" ; See context api implementation for more utilities cases (context use utilities for everything).","title":"Utilities usage"},{"location":"examples/utils/#utilities-usage","text":"In most cases, to use utility directly, all you need to know is type's generics map. It could be either obtained from context ( context.type(Some.class).visibleGenericsMap() ) or resolved directly . class Some < T > { T field ; } Suppose you have generics resolved as generics variable. Map < String , Type > generics = [ \"T\" : List < String >]; Note that this map must include all visible generics (including outer class, method or constructor if they could appear in target types), so better use context api to obtain complete generics map (otherwise UnkownGenericsException could arise at some point). Type field = Some . class . getDeclaredField ( \"field\" ); GenericsUtils . resolveClass ( field , generics ) == List . class ; GenericsUtils . resolveGenericsOf ( field , generics ) == String . class ; TypeToStringUtils . toStringType ( field , generics ) == \"List<String>\" ; TypeToStringUtils . toStringWithNamedGenerics ( field ) == \"List<T>\" ; TypeToStringUtils . toStringWithGenerics ( Some . class , generics ) == \"Some<List<String>>\" ; See context api implementation for more utilities cases (context use utilities for everything).","title":"Utilities usage"},{"location":"examples/vars/","text":"Find variables \u00b6 Could be used for checks if type contains variables: class Base < T > { List < T > get () {} } // List<T> Type type = base . class . getDeclaredMethod ( \"get\" ). getGenericReturnType (); GenericUtils . findVariables ( type ) == [< T >] // <T> is TypeVariable instance","title":"Find variables"},{"location":"examples/vars/#find-variables","text":"Could be used for checks if type contains variables: class Base < T > { List < T > get () {} } // List<T> Type type = base . class . getDeclaredMethod ( \"get\" ). getGenericReturnType (); GenericUtils . findVariables ( type ) == [< T >] // <T> is TypeVariable instance","title":"Find variables"},{"location":"examples/visibility/","text":"Generics visibility \u00b6 public class Outer < A , B , C > { // constructor generic hides class generic C public < C > Outer ( C arg ){} // method generic hides class generic A public < A > A doSmth () {} // inner class hides outer generic (can't see) public class Inner < A , T > { // method generic hides outer class generic public < B > B doSmth2 () {} } } public class Root extends Outer < String , Integer , Long > { // field with inner class Inner < Boolean , String > field1 ; // field with inner class, but with direct outer generics definition Outer < String , String , String >. Inner < Boolean , String > field2 ; } GenericsContext context = GenericsResolver . resolve ( Root . class ); Type generics \u00b6 // no generics declared on Root class context . genericsMap () == [:] // context.toString(): // class Root <-- current // extends Outer<String, Integer, Long> // Outer type generics, resolved from Root hierarchy context . type ( Outer . class ) . genericsMap () == [ \"A\" : String , \"B\" : Integer , \"C\" : Long ] // context.type(Outer.class).toString(): // class Root // extends Outer<String, Integer, Long> <-- current Constructor generics \u00b6 // switch context to constructor context = context . constructor ( Outer . class . getConstructor ( Object . class )) // generics map shows generics of context type (Outer)! context . genericsMap () == [ \"A\" : String , \"B\" : Integer , \"C\" : Long ] context . constructorGenericsMap () == [ \"C\" : Object ] // but actually visible generics are (note that constructor generic C override): context . visibleGenericsMap () == [ \"A\" : String , \"B\" : Integer , \"C\" : Object ] // context.toString(): // class Root // extends Outer<String, Integer, Long> // Outer(Object) <-- current Method generics \u00b6 // switch context to method context = context . method ( Outer . getMethod ( \"doSmth\" )) // generics map shows generics of context type (Outer)! context . genericsMap () == [ \"A\" : String , \"B\" : Integer , \"C\" : Long ] context . methodGenericsMap () == [ \"A\" : Object ] // but actually visible generics are (note that method generic A override): context . visibleGenericsMap () == [ \"A\" : Object , \"B\" : Integer , \"C\" : Long ] // context.toString(): // class Root // extends Outer<String, Integer, Long> // Object doSmth() <-- current Outer class generics \u00b6 // build context for type of field 1 (using outer generics knowledge) context = context . fieldType ( Root . getDeclaredField ( \"field1\" )) context . genericsMap () == [ \"A\" : Boolean , \"T\" : String ] // inner class could use outer generics, so visible outer generics are also stored, // but not A. as it could never be used in context of this inner class context . ownerGenericsMap () == [ \"B\" : Integer , \"C\" : Long ] context . visibleGenericsMap () == [ \"A\" : Boolean , \"T\" : String , \"B\" : Integer , \"C\" : Long ] // context.toString() // class Outer<Object, Integer, Long>.Inner<Boolean, String> resolved in context of Root <-- current Note Tere was an assumption that as Root context contains Outer class (outer for Inner ), then inner class was created inside it and so root generics could be used. It is not always the case, but in most cases inner class is used inside of outer. Different case, when outer class generics are explicitly declared: // build context for type of field 2 (where outer generics are explicitly declared) // note that first we go from previous field1 context into root context (by using rootContext()) // and then resolve second field context context = context . rootContext (). fieldType ( Root . getDeclaredField ( \"field2\" )) context . genericsMap () == [ \"A\" : Boolean , \"T\" : String ] // outer class generics taken directly from field declaration, but note that A // is not counted as not reachable for inner class context . ownerGenericsMap () == [ \"B\" : String , \"C\" : String ] context . visibleGenericsMap () == [ \"A\" : Boolean , \"T\" : String , \"B\" : Integer , \"C\" : Long ] // context.toString() (first Object is not a mistake! A was ignored in outer class): // class Outer<Object, String, String>.Inner<Boolean, String> resolved in context of Root <-- current Resulted inlying context can do everything root context can (context was just resolved with extra information) // navigate to method in inner class context = context . method ( Outer . Inner . getMethod ( \"doSmth2\" )) context . genericsMap () == [ \"A\" : Boolean , \"T\" : String ] // owner generics always shown as is even when actually overridden (for consistency) context . ownerGenericsMap () == [ \"B\" : String , \"C\" : String ] context . methodGenericsMap () == [ \"B\" : Object ] // note that outer generic B is not visible (because of method generic) context . visibleGenericsMap () == [ \"A\" : Boolean , \"T\" : String , \"B\" : Object , \"C\" : String ] // context.toString(): // class Outer<Object, String, String>.Inner<Boolean, String> resolved in context of Root // Object doSmth2() <-- current","title":"Generics visibility"},{"location":"examples/visibility/#generics-visibility","text":"public class Outer < A , B , C > { // constructor generic hides class generic C public < C > Outer ( C arg ){} // method generic hides class generic A public < A > A doSmth () {} // inner class hides outer generic (can't see) public class Inner < A , T > { // method generic hides outer class generic public < B > B doSmth2 () {} } } public class Root extends Outer < String , Integer , Long > { // field with inner class Inner < Boolean , String > field1 ; // field with inner class, but with direct outer generics definition Outer < String , String , String >. Inner < Boolean , String > field2 ; } GenericsContext context = GenericsResolver . resolve ( Root . class );","title":"Generics visibility"},{"location":"examples/visibility/#type-generics","text":"// no generics declared on Root class context . genericsMap () == [:] // context.toString(): // class Root <-- current // extends Outer<String, Integer, Long> // Outer type generics, resolved from Root hierarchy context . type ( Outer . class ) . genericsMap () == [ \"A\" : String , \"B\" : Integer , \"C\" : Long ] // context.type(Outer.class).toString(): // class Root // extends Outer<String, Integer, Long> <-- current","title":"Type generics"},{"location":"examples/visibility/#constructor-generics","text":"// switch context to constructor context = context . constructor ( Outer . class . getConstructor ( Object . class )) // generics map shows generics of context type (Outer)! context . genericsMap () == [ \"A\" : String , \"B\" : Integer , \"C\" : Long ] context . constructorGenericsMap () == [ \"C\" : Object ] // but actually visible generics are (note that constructor generic C override): context . visibleGenericsMap () == [ \"A\" : String , \"B\" : Integer , \"C\" : Object ] // context.toString(): // class Root // extends Outer<String, Integer, Long> // Outer(Object) <-- current","title":"Constructor generics"},{"location":"examples/visibility/#method-generics","text":"// switch context to method context = context . method ( Outer . getMethod ( \"doSmth\" )) // generics map shows generics of context type (Outer)! context . genericsMap () == [ \"A\" : String , \"B\" : Integer , \"C\" : Long ] context . methodGenericsMap () == [ \"A\" : Object ] // but actually visible generics are (note that method generic A override): context . visibleGenericsMap () == [ \"A\" : Object , \"B\" : Integer , \"C\" : Long ] // context.toString(): // class Root // extends Outer<String, Integer, Long> // Object doSmth() <-- current","title":"Method generics"},{"location":"examples/visibility/#outer-class-generics","text":"// build context for type of field 1 (using outer generics knowledge) context = context . fieldType ( Root . getDeclaredField ( \"field1\" )) context . genericsMap () == [ \"A\" : Boolean , \"T\" : String ] // inner class could use outer generics, so visible outer generics are also stored, // but not A. as it could never be used in context of this inner class context . ownerGenericsMap () == [ \"B\" : Integer , \"C\" : Long ] context . visibleGenericsMap () == [ \"A\" : Boolean , \"T\" : String , \"B\" : Integer , \"C\" : Long ] // context.toString() // class Outer<Object, Integer, Long>.Inner<Boolean, String> resolved in context of Root <-- current Note Tere was an assumption that as Root context contains Outer class (outer for Inner ), then inner class was created inside it and so root generics could be used. It is not always the case, but in most cases inner class is used inside of outer. Different case, when outer class generics are explicitly declared: // build context for type of field 2 (where outer generics are explicitly declared) // note that first we go from previous field1 context into root context (by using rootContext()) // and then resolve second field context context = context . rootContext (). fieldType ( Root . getDeclaredField ( \"field2\" )) context . genericsMap () == [ \"A\" : Boolean , \"T\" : String ] // outer class generics taken directly from field declaration, but note that A // is not counted as not reachable for inner class context . ownerGenericsMap () == [ \"B\" : String , \"C\" : String ] context . visibleGenericsMap () == [ \"A\" : Boolean , \"T\" : String , \"B\" : Integer , \"C\" : Long ] // context.toString() (first Object is not a mistake! A was ignored in outer class): // class Outer<Object, String, String>.Inner<Boolean, String> resolved in context of Root <-- current Resulted inlying context can do everything root context can (context was just resolved with extra information) // navigate to method in inner class context = context . method ( Outer . Inner . getMethod ( \"doSmth2\" )) context . genericsMap () == [ \"A\" : Boolean , \"T\" : String ] // owner generics always shown as is even when actually overridden (for consistency) context . ownerGenericsMap () == [ \"B\" : String , \"C\" : String ] context . methodGenericsMap () == [ \"B\" : Object ] // note that outer generic B is not visible (because of method generic) context . visibleGenericsMap () == [ \"A\" : Boolean , \"T\" : String , \"B\" : Object , \"C\" : String ] // context.toString(): // class Outer<Object, String, String>.Inner<Boolean, String> resolved in context of Root // Object doSmth2() <-- current","title":"Outer class generics"},{"location":"guide/cache/","text":"Cache \u00b6 If you use JRebel or other class reloading tool (maybe some other reason) you will need to disable descriptors caching. To do it set system property or environment variable: ru.vyarus.java.generics.resolver.context.GenericsInfoFactory.cache=false Or from code: GenericsInfoFactory . disableCache (); Also you can clear cache manually: GenericsInfoFactory . clearCache ()","title":"Cache"},{"location":"guide/cache/#cache","text":"If you use JRebel or other class reloading tool (maybe some other reason) you will need to disable descriptors caching. To do it set system property or environment variable: ru.vyarus.java.generics.resolver.context.GenericsInfoFactory.cache=false Or from code: GenericsInfoFactory . disableCache (); Also you can clear cache manually: GenericsInfoFactory . clearCache ()","title":"Cache"},{"location":"guide/context/","text":"Context API \u00b6 There are 2 APIs: context API (primary) used to support introspection (reflection analysis) and direct utilities . Context API is safe because it always performs compatibility checks and throws descriptive exceptions. With utilities, usage errors are possible (quite possible to use wrong generics map), but in simple cases it's not a problem. Use API that fits best your use case. Class hierarchy needs to be parsed to properly resolve all generics: GenericsContext context = GenericsResolver . resolve ( Root . class ) Now we can perform introspection of any class in the hierarchy (look methods or fields) and know exact generics. If root class also contains generics, they are resolved by upper generic bound (e.g. <T extends Model> will be resolved as T=Model.class , and resolved as Object.class when no bounds set) Resolved class hierarchy is cached internally, so it's cheap to resolve single class many times (call GenericsResolver.resolve(Class) ). Limit hierarchy resolution \u00b6 You can limit hierarchy resolution depth (or exclude some interfaces) by providing ignored classes: GenericsResolver . resolve ( Root . class , Base . class , SomeInterface . class ) Here hierarchy resolution will stop on Base class (will not be included) and all appeared SomeInterface will be skipped (interfaces are also hierarchical so it could exclude sub hierarchy too). Option exists for very rare cases when some types breaks analysis (as possible bug workaround). Warning When ignored classes specified, resolved generics information is not cached(!) even if complete type resolution was done before (descriptor always computed, but it's not expensive). Context \u00b6 GenericsResolver.resolve(Class) returns immutable context ( GenericsContext ) set to root class (by default). Actually, context is a map ( Map<Class, Map<String, Type>> ) containing generics of all types in hierarchy: class Root // [:] extends Base<Integer, Long> // [T:Integer, K:Long] Note that map could also contain visible outer type generics. E.g. for Outer<A>.Inner<B,C> A,B and C will be contained inside type generics map. It is very important concept: you will always need to resolve types in context of particular class from hierarchy and context ties all methods to that class (selects correct generics collection). To navigate on different class use context . type ( Base . class ) Which returns new instance of context. This method is used to navigate through all types in resoled class hierarchy. Note that new context will use the same root map of generics (it's just a navigation mechanism) and so there is no need to remember root context reference: you can navigate from any type to any type inside the resolved hierarchy. For methods and constructors, which may contain extra generics, generics are resolved in time of method or constructor context navigation. Context operates on types ( Type ), not classes, because only types holds all generics information, including composite generics info (e.g. List<List<String>> ). Any type, obtained using reflection may be resolved through api to real class. Important See context API methods javadoc: it almost always contains example. Moreover, methods are grouped by name to simplify search (you can note generic.. , resolve.. , toString.. groups). All classes in root class hierarchy may be obtained like this: context . getGenericsInfo (). getComposingTypes () This will be all classes and interfaces in hierarchy (including root class), even if they not contain generics. Tip toString() called on context instance returns complete context with current position marker: context.type(Base.class).toString() : class Root extends Base<Integer, Long> <-- current For example, in intellij idea, current context (with resolved generics) and position could be seen by using \"view value\" link inside debugger Class generics \u00b6 First group of context api methods targets context type own generics. All these methods starts from generic.. . For example (in context of Base class), context . genericsMap () == [ T : Integer , K : Long ] Returns complete mapping of generic names to resolved types, which may be used to some name based substitution. context . genericsAsString () == [ \"Integer\" , \"Long\" ] Returns string representation of generic types, which may be used for logging or reporting. If generic value is parameterizable type then string will include it too: \"List<String>\" . See api for all supported methods. Methods \u00b6 When working with methods it's required to use method context: MethodGenericsContext methodContext = context . method ( methodInstance ) This will also check if method belongs to current hierarchy and switch context to methods's declaring class (in order to correctly solve referenced generics). Special method context is important because of method generics, for example: class A { public < T > T method ( T arg ) { ... } } Initially generics are resolved as type, so if you try to analyze generified method parameter it will fail, because of unknown generic (T). Method context resolve method generics as upper bound. In the example above it would be: T == Object . But in more complex example: class A < Q > { public < T extends Q , K extends Cloneable > T method ( T arg , List < K > arg2 ) { ... } } class B extends A < Serializable > Method generics upper bounds could be resolved as: Method method = A . getMethod ( \"method\" , Object . class , Cloneable . class ) GenericsResolver . resolve ( B . class ). method ( method ) . methodGenericTypes () == [ \"T\" : Serializable . class , \"K\" : Cloneable . class ] Method context additional methods to work with parameters and return type: methodContext . resolveParameters () == [ Serializable . class , List . class ] methodContext . resolveReturnClass () == Serializable . class Types resolution api (the same as in types context) will count method generics too: methodContext . resolveGenericOf ( method . getGenericParameterTypes ()[ 1 ]) == Cloneable . class Constructors \u00b6 Constructor could declare generics like: class Some { < T > Some ( T arg ); } To work with constructor generics, constructor context must be created: ConstructorGenericsContext ctorContext = context . constructor ( Some . class . getConstructor ( Object . class )) By analogy with method context, constructor context contains extra methods for working with constructor generics and parameters. Fields \u00b6 Context contains special shortcut methods for working with fields. For example, context . resolveFieldClass ( field ) In essence, it's the same as: context.resolveClass(field.getGenericType()) It is just shorter and, if field does not belongs to current hierarchy, more concrete error will be thrown. But it would be IllegalArgumentException instead of WrongGenericsContextException because field case assumed to be simpler to track and more obvious to predict. Types resolution \u00b6 Both MethodGenericContext and ConstructorGenericContext extends from GenericsContext and so share common api. The only difference is that in method and context contexts amount of known generics could be bigger (due to method/constructor generics). All type resolution api methods starts with 'resolve..'. This api most likely will be used together with reflection introspection of classes in hierarchy (e.g. when searching for method or need to know exact method return type). Any Type could be resolved to actual class (simpler to use in logic) and manual navigation to actual context type is not required. Suppose we have more complex case: class Base < T , K extends Collection < T > { K foo ; } class Root extends Base < Integer , List < Integer >> {...} And we need to know type and actual type of collection in field foo : Field field = Base . class . getField ( \"foo\" ) GenericsContext context = GenericsResolver . resolve ( Root . class ) // this is optional step (result will be the same even without it) . type ( Base . class ) context . resolveClass ( field . getGenericType ()) == List . class context . resolveGenericOf ( field . getGenericType ()) == Integer . class Here you can see how both main class and generic class resolved from single type instance. See api for all supported methods. Note that type navigation ( .type() ) is important when you need to access exact type generics. For example, in order to use type's generics map in direct utility calls. To string \u00b6 class Base < T , K > { T doSomething ( K arg ); } class Root extends Base < Integer , Long > {...} Any type could be resolved as string: context . toStringType ( doSomethingMethod . getGenericReturnType ()) == \"List<Integer>\" Or context class: context . type ( Base . class ). toStringCurrentClass () == \"Base<Integer, Long>\" ; context . type ( Base . class ). toStringCurrentClassDeclaration () == \"Base<T, K>\" To string context method: context . method ( doSomethingMethod ). toStringMethod () == \"Integer doSomething(Long)\" By analogy, constructor context also contains toStringConstructor() method.","title":"Context API"},{"location":"guide/context/#context-api","text":"There are 2 APIs: context API (primary) used to support introspection (reflection analysis) and direct utilities . Context API is safe because it always performs compatibility checks and throws descriptive exceptions. With utilities, usage errors are possible (quite possible to use wrong generics map), but in simple cases it's not a problem. Use API that fits best your use case. Class hierarchy needs to be parsed to properly resolve all generics: GenericsContext context = GenericsResolver . resolve ( Root . class ) Now we can perform introspection of any class in the hierarchy (look methods or fields) and know exact generics. If root class also contains generics, they are resolved by upper generic bound (e.g. <T extends Model> will be resolved as T=Model.class , and resolved as Object.class when no bounds set) Resolved class hierarchy is cached internally, so it's cheap to resolve single class many times (call GenericsResolver.resolve(Class) ).","title":"Context API"},{"location":"guide/context/#limit-hierarchy-resolution","text":"You can limit hierarchy resolution depth (or exclude some interfaces) by providing ignored classes: GenericsResolver . resolve ( Root . class , Base . class , SomeInterface . class ) Here hierarchy resolution will stop on Base class (will not be included) and all appeared SomeInterface will be skipped (interfaces are also hierarchical so it could exclude sub hierarchy too). Option exists for very rare cases when some types breaks analysis (as possible bug workaround). Warning When ignored classes specified, resolved generics information is not cached(!) even if complete type resolution was done before (descriptor always computed, but it's not expensive).","title":"Limit hierarchy resolution"},{"location":"guide/context/#context","text":"GenericsResolver.resolve(Class) returns immutable context ( GenericsContext ) set to root class (by default). Actually, context is a map ( Map<Class, Map<String, Type>> ) containing generics of all types in hierarchy: class Root // [:] extends Base<Integer, Long> // [T:Integer, K:Long] Note that map could also contain visible outer type generics. E.g. for Outer<A>.Inner<B,C> A,B and C will be contained inside type generics map. It is very important concept: you will always need to resolve types in context of particular class from hierarchy and context ties all methods to that class (selects correct generics collection). To navigate on different class use context . type ( Base . class ) Which returns new instance of context. This method is used to navigate through all types in resoled class hierarchy. Note that new context will use the same root map of generics (it's just a navigation mechanism) and so there is no need to remember root context reference: you can navigate from any type to any type inside the resolved hierarchy. For methods and constructors, which may contain extra generics, generics are resolved in time of method or constructor context navigation. Context operates on types ( Type ), not classes, because only types holds all generics information, including composite generics info (e.g. List<List<String>> ). Any type, obtained using reflection may be resolved through api to real class. Important See context API methods javadoc: it almost always contains example. Moreover, methods are grouped by name to simplify search (you can note generic.. , resolve.. , toString.. groups). All classes in root class hierarchy may be obtained like this: context . getGenericsInfo (). getComposingTypes () This will be all classes and interfaces in hierarchy (including root class), even if they not contain generics. Tip toString() called on context instance returns complete context with current position marker: context.type(Base.class).toString() : class Root extends Base<Integer, Long> <-- current For example, in intellij idea, current context (with resolved generics) and position could be seen by using \"view value\" link inside debugger","title":"Context"},{"location":"guide/context/#class-generics","text":"First group of context api methods targets context type own generics. All these methods starts from generic.. . For example (in context of Base class), context . genericsMap () == [ T : Integer , K : Long ] Returns complete mapping of generic names to resolved types, which may be used to some name based substitution. context . genericsAsString () == [ \"Integer\" , \"Long\" ] Returns string representation of generic types, which may be used for logging or reporting. If generic value is parameterizable type then string will include it too: \"List<String>\" . See api for all supported methods.","title":"Class generics"},{"location":"guide/context/#methods","text":"When working with methods it's required to use method context: MethodGenericsContext methodContext = context . method ( methodInstance ) This will also check if method belongs to current hierarchy and switch context to methods's declaring class (in order to correctly solve referenced generics). Special method context is important because of method generics, for example: class A { public < T > T method ( T arg ) { ... } } Initially generics are resolved as type, so if you try to analyze generified method parameter it will fail, because of unknown generic (T). Method context resolve method generics as upper bound. In the example above it would be: T == Object . But in more complex example: class A < Q > { public < T extends Q , K extends Cloneable > T method ( T arg , List < K > arg2 ) { ... } } class B extends A < Serializable > Method generics upper bounds could be resolved as: Method method = A . getMethod ( \"method\" , Object . class , Cloneable . class ) GenericsResolver . resolve ( B . class ). method ( method ) . methodGenericTypes () == [ \"T\" : Serializable . class , \"K\" : Cloneable . class ] Method context additional methods to work with parameters and return type: methodContext . resolveParameters () == [ Serializable . class , List . class ] methodContext . resolveReturnClass () == Serializable . class Types resolution api (the same as in types context) will count method generics too: methodContext . resolveGenericOf ( method . getGenericParameterTypes ()[ 1 ]) == Cloneable . class","title":"Methods"},{"location":"guide/context/#constructors","text":"Constructor could declare generics like: class Some { < T > Some ( T arg ); } To work with constructor generics, constructor context must be created: ConstructorGenericsContext ctorContext = context . constructor ( Some . class . getConstructor ( Object . class )) By analogy with method context, constructor context contains extra methods for working with constructor generics and parameters.","title":"Constructors"},{"location":"guide/context/#fields","text":"Context contains special shortcut methods for working with fields. For example, context . resolveFieldClass ( field ) In essence, it's the same as: context.resolveClass(field.getGenericType()) It is just shorter and, if field does not belongs to current hierarchy, more concrete error will be thrown. But it would be IllegalArgumentException instead of WrongGenericsContextException because field case assumed to be simpler to track and more obvious to predict.","title":"Fields"},{"location":"guide/context/#types-resolution","text":"Both MethodGenericContext and ConstructorGenericContext extends from GenericsContext and so share common api. The only difference is that in method and context contexts amount of known generics could be bigger (due to method/constructor generics). All type resolution api methods starts with 'resolve..'. This api most likely will be used together with reflection introspection of classes in hierarchy (e.g. when searching for method or need to know exact method return type). Any Type could be resolved to actual class (simpler to use in logic) and manual navigation to actual context type is not required. Suppose we have more complex case: class Base < T , K extends Collection < T > { K foo ; } class Root extends Base < Integer , List < Integer >> {...} And we need to know type and actual type of collection in field foo : Field field = Base . class . getField ( \"foo\" ) GenericsContext context = GenericsResolver . resolve ( Root . class ) // this is optional step (result will be the same even without it) . type ( Base . class ) context . resolveClass ( field . getGenericType ()) == List . class context . resolveGenericOf ( field . getGenericType ()) == Integer . class Here you can see how both main class and generic class resolved from single type instance. See api for all supported methods. Note that type navigation ( .type() ) is important when you need to access exact type generics. For example, in order to use type's generics map in direct utility calls.","title":"Types resolution"},{"location":"guide/context/#to-string","text":"class Base < T , K > { T doSomething ( K arg ); } class Root extends Base < Integer , Long > {...} Any type could be resolved as string: context . toStringType ( doSomethingMethod . getGenericReturnType ()) == \"List<Integer>\" Or context class: context . type ( Base . class ). toStringCurrentClass () == \"Base<Integer, Long>\" ; context . type ( Base . class ). toStringCurrentClassDeclaration () == \"Base<T, K>\" To string context method: context . method ( doSomethingMethod ). toStringMethod () == \"Integer doSomething(Long)\" By analogy, constructor context also contains toStringConstructor() method.","title":"To string"},{"location":"guide/inlying/","text":"Inlying context \u00b6 Inlying context is generics context build for type inside current context. class Root < T > { Inlying < T > field ; } Suppose we analyzing some hierarchy with root and need to build hierarchy for field type. If we do GenericsResolver.resolve(Inlying) then we will lost information about known generic T. So we need inlying context (lying in current context): // note that .type(Root.class) is not required, and used just to show that root // context contains Root.class GenericsContext inlyingContext = context . type ( Root . class ) . fieldType ( Root . class . getDeclaredField ( \"field\" )) Resulted context (for Inlying ) will contain known value for root generic T. You can check if current context is inlying by context.isInlying() and navigate to root context using context.rootContext() . Note Inlying context also inherits all ignored classes specified during root context creation ( GenericResolver.resolve(Root.class, [classes to ignore]) ). If target type does not contains generics then type resolution will be cached (because it is the same as direct type resolution). Inlying inner classes \u00b6 Note: inner class requires outer class instance for creation (differs from static nested classes ) class Outer < T > { class Inner { // inner class use owner class generic T getSomething () {} } } class Root extends Outer < String > { Inner field ; } Inner class could access generics of owner class (T). In most cases inner class is used inside owner class and so if you building inlying context for inner class and root context contains outer class in hierarchy then outer class generics used from root context // root context GenericsContext context = GenericsResolver . resolve ( Root . class ) // inlying context . fieldType ( Root . class . getDeclaredField ( \"field\" )); context . ownerGenericsMap () == [ \"T\" : String ] // visible generics of Outer Note that this assumption is true not for all cases, but for most. When outer class generics declared explicitly: Outer < Long >. Inner field ; Explicit declaration is used instead: context.ownerGenericsMap() == [\"T\": Long] . Inlying context for sub type \u00b6 In some (rare) cases, you may need to build inlying context for sub type of declared type: class Base < T > { Inlying < T > field ; } class Root extends Base < List < String >> {} class InlyingExt < K > extends Inlying < List < K >> {} Possible case is object instance analysis when type information could be taken both from class declaration and actual values. GenericsContext context = GenericsResolver . resolve ( Root . class ) . fieldTypeAs ( Base . class . getDeclaredField ( \"field\" ), InlyingExt . class ); // InlyingExt generic tracked from known Inlying<List<String>> context . genericsMap () == [ \"K\" : String ] // context.toString(): // class InlyingExt<String> resolved in context of Root <-- current // extends Inlying<List<String> General case \u00b6 Field cases above are shortcuts for general inlying contexts resolution methods: context . inlyingType ( type ) context . inlyingType ( type , asType ) It may be used to build such context for any type. For example, it may be required during method parameters (or return type) inspection: public class Some < K > { List < K > fld ; } public class Base < T > { public void something ( Some < T > some ) {} } public class Root extends Base < String > {} Resolvingmethod context for root class: Method method = Base . class . getMethod ( \"something\" , Some . class ); GenericsContext methodContext = GenericsResolver . resolve ( Root . class ). method ( methiod ); If we want to resolve field fld type in method parameter type Some we need to build inlying (sub) context for it under knowing generics context: GenericsContext paramContext = methodContext . inlyingType ( method . getGenericParameterTypes ()[ 0 ]) paramContext . currentClass () == Some paramContext . genericsMap () == [ K : Strng ] Here you can see that parameter context was created with correct generic value. Tip This was just an example of raw type context creation (under resolved generic context). Specifically, for methods there is a shortcut method for building parameter context: GenericsContext paramContext = methodContext . parameterType ( 0 )","title":"Inlying contexts"},{"location":"guide/inlying/#inlying-context","text":"Inlying context is generics context build for type inside current context. class Root < T > { Inlying < T > field ; } Suppose we analyzing some hierarchy with root and need to build hierarchy for field type. If we do GenericsResolver.resolve(Inlying) then we will lost information about known generic T. So we need inlying context (lying in current context): // note that .type(Root.class) is not required, and used just to show that root // context contains Root.class GenericsContext inlyingContext = context . type ( Root . class ) . fieldType ( Root . class . getDeclaredField ( \"field\" )) Resulted context (for Inlying ) will contain known value for root generic T. You can check if current context is inlying by context.isInlying() and navigate to root context using context.rootContext() . Note Inlying context also inherits all ignored classes specified during root context creation ( GenericResolver.resolve(Root.class, [classes to ignore]) ). If target type does not contains generics then type resolution will be cached (because it is the same as direct type resolution).","title":"Inlying context"},{"location":"guide/inlying/#inlying-inner-classes","text":"Note: inner class requires outer class instance for creation (differs from static nested classes ) class Outer < T > { class Inner { // inner class use owner class generic T getSomething () {} } } class Root extends Outer < String > { Inner field ; } Inner class could access generics of owner class (T). In most cases inner class is used inside owner class and so if you building inlying context for inner class and root context contains outer class in hierarchy then outer class generics used from root context // root context GenericsContext context = GenericsResolver . resolve ( Root . class ) // inlying context . fieldType ( Root . class . getDeclaredField ( \"field\" )); context . ownerGenericsMap () == [ \"T\" : String ] // visible generics of Outer Note that this assumption is true not for all cases, but for most. When outer class generics declared explicitly: Outer < Long >. Inner field ; Explicit declaration is used instead: context.ownerGenericsMap() == [\"T\": Long] .","title":"Inlying inner classes"},{"location":"guide/inlying/#inlying-context-for-sub-type","text":"In some (rare) cases, you may need to build inlying context for sub type of declared type: class Base < T > { Inlying < T > field ; } class Root extends Base < List < String >> {} class InlyingExt < K > extends Inlying < List < K >> {} Possible case is object instance analysis when type information could be taken both from class declaration and actual values. GenericsContext context = GenericsResolver . resolve ( Root . class ) . fieldTypeAs ( Base . class . getDeclaredField ( \"field\" ), InlyingExt . class ); // InlyingExt generic tracked from known Inlying<List<String>> context . genericsMap () == [ \"K\" : String ] // context.toString(): // class InlyingExt<String> resolved in context of Root <-- current // extends Inlying<List<String>","title":"Inlying context for sub type"},{"location":"guide/inlying/#general-case","text":"Field cases above are shortcuts for general inlying contexts resolution methods: context . inlyingType ( type ) context . inlyingType ( type , asType ) It may be used to build such context for any type. For example, it may be required during method parameters (or return type) inspection: public class Some < K > { List < K > fld ; } public class Base < T > { public void something ( Some < T > some ) {} } public class Root extends Base < String > {} Resolvingmethod context for root class: Method method = Base . class . getMethod ( \"something\" , Some . class ); GenericsContext methodContext = GenericsResolver . resolve ( Root . class ). method ( methiod ); If we want to resolve field fld type in method parameter type Some we need to build inlying (sub) context for it under knowing generics context: GenericsContext paramContext = methodContext . inlyingType ( method . getGenericParameterTypes ()[ 0 ]) paramContext . currentClass () == Some paramContext . genericsMap () == [ K : Strng ] Here you can see that parameter context was created with correct generic value. Tip This was just an example of raw type context creation (under resolved generic context). Specifically, for methods there is a shortcut method for building parameter context: GenericsContext paramContext = methodContext . parameterType ( 0 )","title":"General case"},{"location":"guide/utils/","text":"Low level api \u00b6 Note Context, produced by GenericsResolver is just a convenient utility to simplify usage. Internally it consists of a Map with resolved type generics and utilities calls, which may be used directly. Tip If known generics exists only as List, then it can be converted to map with: Map < String , Type > generics = GenericsUtils . createGenericsMap ( Some . class , knownGenericsList ); (often required conversion) Utilities \u00b6 TypeUtils - pure types operations (unknown generics ignored) like .isCompatible(Type, Type) == boolean , .getMoreSpecific(Type, Type) , .isAssignable(Type, Type) TypeToStringUtils - various to string helper methods GenericsUtils - generics manipulations (all resolve* methods from context) (requires known generics map to properly resolve types). GenericsResolutionUtils - class analysis (mostly useful for root type resolution - hierarchy computation). Creates generics maps, used for type resolutions. Special, and most useful case is direct class generics resolution (lower bounds): GenericResolutionUtils.resolveRawGenetics(Class type) == Map<String, Type> GenericsTrackingUtils - resolution of root class's unknown generics by known middle class generics. Used to compute more specific generics for root class before actual resolution (for inlying contexts). GenericInfoUtils - GenericsInfo factory for all cases: direct class, sub type, and sub type with target class. Essentially it's the same as GenericsResolver but without context wrapping (navigator) and without cache. Warning Some methods may not do what you expect! For example TypeUtils.getOuter(Type) is not the same as Classs#getEnclosingClass() (which returns outer class for static classes and interfaces too). Another example is ToStringUtils.toStringType() which prints outer class only if provided type is ParameterizedType with not null owner. I essence, api oriented to generic resolution cases and all edge cases are described in javadoc. Tip See utiltity classes or javadoc for actual api methods. Almost all of them contain examples inside javadoc (no need to duplicate detailed description here). Special maps \u00b6 Special maps may be used for generics resolution: IgnoreGenericsMap - use to ignore unknown generics (instead of fail). For example, GenericsUtils.resolveClass(List<T>, new IgnoreGenericsMap()) == List.class PrintableGenericsMap - special map for TypeToStringUtils to print unkown generics (instead of fail). For example, TypeToStringUtils.toStringType(List<T>, new PrintableGenericsMap()) == \"List<T>\"","title":"Low level API"},{"location":"guide/utils/#low-level-api","text":"Note Context, produced by GenericsResolver is just a convenient utility to simplify usage. Internally it consists of a Map with resolved type generics and utilities calls, which may be used directly. Tip If known generics exists only as List, then it can be converted to map with: Map < String , Type > generics = GenericsUtils . createGenericsMap ( Some . class , knownGenericsList ); (often required conversion)","title":"Low level api"},{"location":"guide/utils/#utilities","text":"TypeUtils - pure types operations (unknown generics ignored) like .isCompatible(Type, Type) == boolean , .getMoreSpecific(Type, Type) , .isAssignable(Type, Type) TypeToStringUtils - various to string helper methods GenericsUtils - generics manipulations (all resolve* methods from context) (requires known generics map to properly resolve types). GenericsResolutionUtils - class analysis (mostly useful for root type resolution - hierarchy computation). Creates generics maps, used for type resolutions. Special, and most useful case is direct class generics resolution (lower bounds): GenericResolutionUtils.resolveRawGenetics(Class type) == Map<String, Type> GenericsTrackingUtils - resolution of root class's unknown generics by known middle class generics. Used to compute more specific generics for root class before actual resolution (for inlying contexts). GenericInfoUtils - GenericsInfo factory for all cases: direct class, sub type, and sub type with target class. Essentially it's the same as GenericsResolver but without context wrapping (navigator) and without cache. Warning Some methods may not do what you expect! For example TypeUtils.getOuter(Type) is not the same as Classs#getEnclosingClass() (which returns outer class for static classes and interfaces too). Another example is ToStringUtils.toStringType() which prints outer class only if provided type is ParameterizedType with not null owner. I essence, api oriented to generic resolution cases and all edge cases are described in javadoc. Tip See utiltity classes or javadoc for actual api methods. Almost all of them contain examples inside javadoc (no need to duplicate detailed description here).","title":"Utilities"},{"location":"guide/utils/#special-maps","text":"Special maps may be used for generics resolution: IgnoreGenericsMap - use to ignore unknown generics (instead of fail). For example, GenericsUtils.resolveClass(List<T>, new IgnoreGenericsMap()) == List.class PrintableGenericsMap - special map for TypeToStringUtils to print unkown generics (instead of fail). For example, TypeToStringUtils.toStringType(List<T>, new PrintableGenericsMap()) == \"List<T>\"","title":"Special maps"},{"location":"guide/walker/","text":"Types walker \u00b6 Special api for walking on two types side by side. Usages: compatibility check and more specific type detection. TypesWalker . walk ( Type , Type , TypesVisitor ); TypesVisitor implementation receive either incompatibility signal (and processing stops after that) or types for comparison. Visitor could stop processing at any stage. For example, for List<String> and List<Integer> : next(List, List) incompatibleHierarchy(String, Integer) It will correctly balance types by building hierarchy, where appropriate: List<MyCallable<String>> and ArrayList<Callable<String> : next(List, ArrayList) // resolve generic for List on the right next(MyCallable, Callable) // now compute callable generic on the left next(String, String) Types rules \u00b6 Java wildcard rules are not strictly followed during type compatibility checks, because many rules are useless at runtime. Object always assumed as not known type. List<?> == List == List<Object> == List<? super Object> == List<? extends Object> Object is compatible and assignable to everything. Object is assignable to List<String> and List<String> is assignable to Object (type not known - assuming compatibility). <? extends Something> is considered as just Something . <? super Something> is compatible with any super type of Something but not with any sub type ( SomethingExt extends Something ). Object is assignable to <? extends String> , but later is more specific (contains more type information). <? super Number> is assignable to <? super Integer> , but not opposite! Primitives are compared as wrapper types (e.g. Integer for int ), but not primitive arrays! Table below compares different TypeUtils methods (implemented using walker api): type 1 type 2 isAssignable isCompatible isMoreSpecific Object List + + - String Integer - - - List Object + + + List List + + + List List<String> + + - List<String> List<Integer> - - - List<String> List + + + ArrayList List<String> + + + List<String> ArrayList - + - List<String> ArrayList<String> - + - List List<? super String> + + - List<? super String> List + + + List<? super Number> List<? super Integer> + + + List<String> List<? super String> + + + List<? super String> List<String> - + - List[] List<? super String>[] + + - List<? super String>[] List[] + + + Integer[] Object[] + + + Object[] Integer[] + + - Some<String, Object> Some<String, String> + + - Some<String, String> Some<String, Object> + + + Some<String, Long> Some<String, Boolean> - - - Integer long - - - Integer int + + + int Number + + + Number int - + - int Comparable + + + int Comparable<Long> - - - int long - - - int[] long[] - - - int[] Object[] - - - int[] Integer[] - - -","title":"Types walker"},{"location":"guide/walker/#types-walker","text":"Special api for walking on two types side by side. Usages: compatibility check and more specific type detection. TypesWalker . walk ( Type , Type , TypesVisitor ); TypesVisitor implementation receive either incompatibility signal (and processing stops after that) or types for comparison. Visitor could stop processing at any stage. For example, for List<String> and List<Integer> : next(List, List) incompatibleHierarchy(String, Integer) It will correctly balance types by building hierarchy, where appropriate: List<MyCallable<String>> and ArrayList<Callable<String> : next(List, ArrayList) // resolve generic for List on the right next(MyCallable, Callable) // now compute callable generic on the left next(String, String)","title":"Types walker"},{"location":"guide/walker/#types-rules","text":"Java wildcard rules are not strictly followed during type compatibility checks, because many rules are useless at runtime. Object always assumed as not known type. List<?> == List == List<Object> == List<? super Object> == List<? extends Object> Object is compatible and assignable to everything. Object is assignable to List<String> and List<String> is assignable to Object (type not known - assuming compatibility). <? extends Something> is considered as just Something . <? super Something> is compatible with any super type of Something but not with any sub type ( SomethingExt extends Something ). Object is assignable to <? extends String> , but later is more specific (contains more type information). <? super Number> is assignable to <? super Integer> , but not opposite! Primitives are compared as wrapper types (e.g. Integer for int ), but not primitive arrays! Table below compares different TypeUtils methods (implemented using walker api): type 1 type 2 isAssignable isCompatible isMoreSpecific Object List + + - String Integer - - - List Object + + + List List + + + List List<String> + + - List<String> List<Integer> - - - List<String> List + + + ArrayList List<String> + + + List<String> ArrayList - + - List<String> ArrayList<String> - + - List List<? super String> + + - List<? super String> List + + + List<? super Number> List<? super Integer> + + + List<String> List<? super String> + + + List<? super String> List<String> - + - List[] List<? super String>[] + + - List<? super String>[] List[] + + + Integer[] Object[] + + + Object[] Integer[] + + - Some<String, Object> Some<String, String> + + - Some<String, String> Some<String, Object> + + + Some<String, Long> Some<String, Boolean> - - - Integer long - - - Integer int + + + int Number + + + Number int - + - int Comparable + + + int Comparable<Long> - - - int long - - - int[] long[] - - - int[] Object[] - - - int[] Integer[] - - -","title":"Types rules"}]}